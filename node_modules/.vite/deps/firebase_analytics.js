import {
  Component,
  ErrorFactory,
  FirebaseError,
  Logger,
  _getProvider,
  _registerComponent,
  areCookiesEnabled,
  calculateBackoffMillis,
  deepEqual,
  getApp,
  getModularInstance,
  isBrowserExtension,
  isIndexedDBAvailable,
  openDB,
  registerVersion,
  validateIndexedDBOpenable
} from "./chunk-RTSFQ6BN.js";
import {
  __export
} from "./chunk-G3PMV62Z.js";

// node_modules/safevalues/dist/mjs/environment/dev.js
(() => {
  if (typeof process === "undefined") {
    window.process = {
      env: {
        NODE_ENV: "development"
      }
    };
  }
})();

// node_modules/safevalues/dist/mjs/internals/secrets.js
var secretToken = {};
function ensureTokenIsValid(token) {
  if (true) {
    if (token !== secretToken) {
      throw new Error("Bad secret");
    }
  }
}

// node_modules/safevalues/dist/mjs/internals/attribute_impl.js
var SafeAttributePrefix = class {
  constructor(token, value) {
    if (true) {
      ensureTokenIsValid(token);
    }
    this.privateDoNotAccessOrElseWrappedAttributePrefix = value;
  }
  toString() {
    return this.privateDoNotAccessOrElseWrappedAttributePrefix;
  }
};
function isAttributePrefix(value) {
  return value instanceof SafeAttributePrefix;
}
function unwrapAttributePrefix(value) {
  if (isAttributePrefix(value)) {
    return value.privateDoNotAccessOrElseWrappedAttributePrefix;
  }
  let message = "";
  if (true) {
    message = `Unexpected type when unwrapping SafeAttributePrefix, got '${value}' of type '${typeof value}'`;
  }
  throw new Error(message);
}

// node_modules/safevalues/dist/mjs/internals/string_literal.js
function assertIsTemplateObject(templateObj, numExprs) {
  if (!isTemplateObject(templateObj) || numExprs + 1 !== templateObj.length) {
    throw new TypeError(`
    ############################## ERROR ##############################

    It looks like you are trying to call a template tag function (fn\`...\`)
    using the normal function syntax (fn(...)), which is not supported.

    The functions in the safevalues library are not designed to be called
    like normal functions, and doing so invalidates the security guarantees
    that safevalues provides.

    If you are stuck and not sure how to proceed, please reach out to us
    instead through:
     - https://github.com/google/safevalues/issues

    ############################## ERROR ##############################`);
  }
}
function checkFrozen(templateObj) {
  return Object.isFrozen(templateObj) && Object.isFrozen(templateObj.raw);
}
function checkTranspiled(fn) {
  return fn.toString().indexOf("`") === -1;
}
var isTranspiled = checkTranspiled((tag) => tag``) || checkTranspiled((tag) => tag`\0`) || checkTranspiled((tag) => tag`\n`) || checkTranspiled((tag) => tag`\u0000`);
var frozenTSA = checkFrozen`` && checkFrozen`\0` && checkFrozen`\n` && checkFrozen`\u0000`;
function isTemplateObject(templateObj) {
  if (!Array.isArray(templateObj) || !Array.isArray(templateObj.raw)) {
    return false;
  }
  if (templateObj.length !== templateObj.raw.length) {
    return false;
  }
  if (!isTranspiled && templateObj === templateObj.raw) {
    return false;
  }
  if ((!isTranspiled || frozenTSA) && !checkFrozen(templateObj)) {
    return false;
  }
  return true;
}

// node_modules/safevalues/dist/mjs/internals/trusted_types.js
var trustedTypesPolicyName = "google#safe";
function trustedTypes() {
  if (typeof window !== "undefined") {
    return window.trustedTypes;
  }
  return void 0;
}
function getTrustedTypes() {
  var _a;
  return trustedTypesPolicyName !== "" ? (_a = trustedTypes()) !== null && _a !== void 0 ? _a : null : null;
}
var trustedTypesPolicy;
function getTrustedTypesPolicy() {
  var _a, _b;
  if (trustedTypesPolicy === void 0) {
    try {
      trustedTypesPolicy = (_b = (_a = getTrustedTypes()) === null || _a === void 0 ? void 0 : _a.createPolicy(trustedTypesPolicyName, {
        createHTML: (s) => s,
        createScript: (s) => s,
        createScriptURL: (s) => s
      })) !== null && _b !== void 0 ? _b : null;
    } catch (_c) {
      trustedTypesPolicy = null;
    }
  }
  return trustedTypesPolicy;
}

// node_modules/safevalues/dist/mjs/internals/html_impl.js
var HtmlImpl = class {
  constructor(html, token) {
    ensureTokenIsValid(token);
    this.privateDoNotAccessOrElseWrappedHtml = html;
  }
  toString() {
    return this.privateDoNotAccessOrElseWrappedHtml.toString();
  }
};
function createTrustedHtmlOrPolyfill(html, trusted) {
  return trusted !== null && trusted !== void 0 ? trusted : new HtmlImpl(html, secretToken);
}
var GlobalTrustedHTML = typeof window !== "undefined" ? window.TrustedHTML : void 0;
function createHtmlInternal(html) {
  var _a;
  const noinlineHtml = html;
  return createTrustedHtmlOrPolyfill(noinlineHtml, (_a = getTrustedTypesPolicy()) === null || _a === void 0 ? void 0 : _a.createHTML(noinlineHtml));
}
var EMPTY_HTML = (() => {
  var _a;
  return createTrustedHtmlOrPolyfill("", (_a = getTrustedTypes()) === null || _a === void 0 ? void 0 : _a.emptyHTML);
})();
function unwrapHtml(value) {
  var _a;
  if ((_a = getTrustedTypes()) === null || _a === void 0 ? void 0 : _a.isHTML(value)) {
    return value;
  } else if (value instanceof HtmlImpl) {
    return value.privateDoNotAccessOrElseWrappedHtml;
  } else {
    let message = "";
    if (true) {
      message = "Unexpected type when unwrapping SafeHtml";
    }
    throw new Error(message);
  }
}

// node_modules/safevalues/dist/mjs/internals/resource_url_impl.js
var ResourceUrlImpl = class {
  constructor(url, token) {
    ensureTokenIsValid(token);
    this.privateDoNotAccessOrElseWrappedResourceUrl = url;
  }
  toString() {
    return this.privateDoNotAccessOrElseWrappedResourceUrl.toString();
  }
};
var GlobalTrustedScriptURL = typeof window !== "undefined" ? window.TrustedScriptURL : void 0;
function createResourceUrlInternal(url) {
  var _a;
  const noinlineUrl = url;
  const trustedScriptURL = (_a = getTrustedTypesPolicy()) === null || _a === void 0 ? void 0 : _a.createScriptURL(noinlineUrl);
  return trustedScriptURL !== null && trustedScriptURL !== void 0 ? trustedScriptURL : new ResourceUrlImpl(noinlineUrl, secretToken);
}
function isResourceUrl(value) {
  var _a;
  return ((_a = getTrustedTypes()) === null || _a === void 0 ? void 0 : _a.isScriptURL(value)) || value instanceof ResourceUrlImpl;
}
function unwrapResourceUrl(value) {
  var _a;
  if ((_a = getTrustedTypes()) === null || _a === void 0 ? void 0 : _a.isScriptURL(value)) {
    return value;
  } else if (value instanceof ResourceUrlImpl) {
    return value.privateDoNotAccessOrElseWrappedResourceUrl;
  } else {
    let message = "";
    if (true) {
      message = "Unexpected type when unwrapping TrustedResourceUrl";
    }
    throw new Error(message);
  }
}

// node_modules/safevalues/dist/mjs/internals/script_impl.js
var ScriptImpl = class {
  constructor(script, token) {
    ensureTokenIsValid(token);
    this.privateDoNotAccessOrElseWrappedScript = script;
  }
  toString() {
    return this.privateDoNotAccessOrElseWrappedScript.toString();
  }
};
function createTrustedScriptOrPolyfill(script, trusted) {
  return trusted !== null && trusted !== void 0 ? trusted : new ScriptImpl(script, secretToken);
}
var GlobalTrustedScript = typeof window !== "undefined" ? window.TrustedScript : void 0;
function createScriptInternal(script) {
  var _a;
  const noinlineScript = script;
  return createTrustedScriptOrPolyfill(noinlineScript, (_a = getTrustedTypesPolicy()) === null || _a === void 0 ? void 0 : _a.createScript(noinlineScript));
}
var EMPTY_SCRIPT = (() => {
  var _a;
  return createTrustedScriptOrPolyfill("", (_a = getTrustedTypes()) === null || _a === void 0 ? void 0 : _a.emptyScript);
})();
function unwrapScript(value) {
  var _a;
  if ((_a = getTrustedTypes()) === null || _a === void 0 ? void 0 : _a.isScript(value)) {
    return value;
  } else if (value instanceof ScriptImpl) {
    return value.privateDoNotAccessOrElseWrappedScript;
  } else {
    let message = "";
    if (true) {
      message = "Unexpected type when unwrapping SafeScript";
    }
    throw new Error(message);
  }
}

// node_modules/safevalues/dist/mjs/builders/html_builders.js
function nodeToHtmlInternal(node, temporaryRoot) {
  temporaryRoot.appendChild(node);
  let serializedNewTree = new XMLSerializer().serializeToString(temporaryRoot);
  serializedNewTree = serializedNewTree.slice(serializedNewTree.indexOf(">") + 1, serializedNewTree.lastIndexOf("</"));
  return createHtmlInternal(serializedNewTree);
}

// node_modules/safevalues/dist/mjs/internals/pure.js
function pure(valueOf) {
  return { valueOf }.valueOf();
}

// node_modules/safevalues/dist/mjs/builders/url_builders.js
function extractScheme(url) {
  let parsedUrl;
  try {
    parsedUrl = new URL(url);
  } catch (e) {
    return "https:";
  }
  return parsedUrl.protocol;
}
var ALLOWED_SCHEMES = ["data:", "http:", "https:", "mailto:", "ftp:"];
var IS_NOT_JAVASCRIPT_URL_PATTERN = /^\s*(?!javascript:)(?:[\w+.-]+:|[^:/?#]*(?:[/?#]|$))/i;
function reportJavaScriptUrl(url) {
  const hasJavascriptUrlScheme = !IS_NOT_JAVASCRIPT_URL_PATTERN.test(url);
  if (hasJavascriptUrlScheme) {
    if (true) {
      console.error(`A URL with content '${url}' was sanitized away.`);
    }
  }
  return hasJavascriptUrlScheme;
}
function sanitizeJavaScriptUrl(url) {
  if (reportJavaScriptUrl(url)) {
    return void 0;
  }
  return url;
}
function unwrapUrlOrSanitize(url) {
  return sanitizeJavaScriptUrl(url);
}
function restrictivelySanitizeUrl(url) {
  const parsedScheme = extractScheme(url);
  if (parsedScheme !== void 0 && ALLOWED_SCHEMES.indexOf(parsedScheme.toLowerCase()) !== -1) {
    return url;
  }
  return "about:invalid#zClosurez";
}

// node_modules/safevalues/dist/mjs/dom/globals/range.js
var range_exports = {};
__export(range_exports, {
  createContextualFragment: () => createContextualFragment
});
function createContextualFragment(range, html) {
  return range.createContextualFragment(unwrapHtml(html));
}

// node_modules/safevalues/dist/mjs/builders/html_sanitizer/inert_fragment.js
function createInertFragment(dirtyHtml, inertDocument) {
  if (true) {
    if (inertDocument.defaultView) {
      throw new Error("createInertFragment called with non-inert document");
    }
  }
  const range = inertDocument.createRange();
  range.selectNode(inertDocument.body);
  const temporarySafeHtml = createHtmlInternal(dirtyHtml);
  return createContextualFragment(range, temporarySafeHtml);
}

// node_modules/safevalues/dist/mjs/builders/html_sanitizer/no_clobber.js
function getNodeName(node) {
  const nodeName = node.nodeName;
  return typeof nodeName === "string" ? nodeName : "FORM";
}
function isText(node) {
  return node.nodeType === 3;
}
function isElement(node) {
  const nodeType = node.nodeType;
  return nodeType === 1 || typeof nodeType !== "number";
}

// node_modules/safevalues/dist/mjs/builders/html_sanitizer/resource_url_policy.js
var ResourceUrlPolicyHintsType;
(function(ResourceUrlPolicyHintsType2) {
  ResourceUrlPolicyHintsType2[ResourceUrlPolicyHintsType2["STYLE_TAG"] = 0] = "STYLE_TAG";
  ResourceUrlPolicyHintsType2[ResourceUrlPolicyHintsType2["STYLE_ATTRIBUTE"] = 1] = "STYLE_ATTRIBUTE";
  ResourceUrlPolicyHintsType2[ResourceUrlPolicyHintsType2["HTML_ATTRIBUTE"] = 2] = "HTML_ATTRIBUTE";
})(ResourceUrlPolicyHintsType || (ResourceUrlPolicyHintsType = {}));
function parseUrl(value) {
  try {
    return new URL(value, window.document.baseURI);
  } catch (e) {
    return new URL("about:invalid");
  }
}

// node_modules/safevalues/dist/mjs/builders/html_sanitizer/sanitizer_table/sanitizer_table.js
var SanitizerTable = class {
  constructor(allowedElements, elementPolicies, allowedGlobalAttributes, globalAttributePolicies, globallyAllowedAttributePrefixes) {
    this.allowedElements = allowedElements;
    this.elementPolicies = elementPolicies;
    this.allowedGlobalAttributes = allowedGlobalAttributes;
    this.globalAttributePolicies = globalAttributePolicies;
    this.globallyAllowedAttributePrefixes = globallyAllowedAttributePrefixes;
  }
  isAllowedElement(elementName) {
    return elementName !== "FORM" && (this.allowedElements.has(elementName) || this.elementPolicies.has(elementName));
  }
  getAttributePolicy(attributeName, elementName) {
    const elementPolicy = this.elementPolicies.get(elementName);
    if (elementPolicy === null || elementPolicy === void 0 ? void 0 : elementPolicy.has(attributeName)) {
      return elementPolicy.get(attributeName);
    }
    if (this.allowedGlobalAttributes.has(attributeName)) {
      return { policyAction: AttributePolicyAction.KEEP };
    }
    const globalPolicy = this.globalAttributePolicies.get(attributeName);
    if (globalPolicy) {
      return globalPolicy;
    }
    if (this.globallyAllowedAttributePrefixes && [...this.globallyAllowedAttributePrefixes].some((prefix) => attributeName.indexOf(prefix) === 0)) {
      return { policyAction: AttributePolicyAction.KEEP };
    }
    return { policyAction: AttributePolicyAction.DROP };
  }
};
var AttributePolicyAction;
(function(AttributePolicyAction2) {
  AttributePolicyAction2[AttributePolicyAction2["DROP"] = 0] = "DROP";
  AttributePolicyAction2[AttributePolicyAction2["KEEP"] = 1] = "KEEP";
  AttributePolicyAction2[AttributePolicyAction2["KEEP_AND_SANITIZE_URL"] = 2] = "KEEP_AND_SANITIZE_URL";
  AttributePolicyAction2[AttributePolicyAction2["KEEP_AND_NORMALIZE"] = 3] = "KEEP_AND_NORMALIZE";
  AttributePolicyAction2[AttributePolicyAction2["KEEP_AND_SANITIZE_STYLE"] = 4] = "KEEP_AND_SANITIZE_STYLE";
  AttributePolicyAction2[AttributePolicyAction2["KEEP_AND_USE_RESOURCE_URL_POLICY"] = 5] = "KEEP_AND_USE_RESOURCE_URL_POLICY";
  AttributePolicyAction2[AttributePolicyAction2["KEEP_AND_USE_RESOURCE_URL_POLICY_FOR_SRCSET"] = 6] = "KEEP_AND_USE_RESOURCE_URL_POLICY_FOR_SRCSET";
})(AttributePolicyAction || (AttributePolicyAction = {}));

// node_modules/safevalues/dist/mjs/builders/html_sanitizer/sanitizer_table/default_sanitizer_table.js
var ALLOWED_ELEMENTS = [
  "ARTICLE",
  "SECTION",
  "NAV",
  "ASIDE",
  "H1",
  "H2",
  "H3",
  "H4",
  "H5",
  "H6",
  "HEADER",
  "FOOTER",
  "ADDRESS",
  "P",
  "HR",
  "PRE",
  "BLOCKQUOTE",
  "OL",
  "UL",
  "LH",
  "LI",
  "DL",
  "DT",
  "DD",
  "FIGURE",
  "FIGCAPTION",
  "MAIN",
  "DIV",
  "EM",
  "STRONG",
  "SMALL",
  "S",
  "CITE",
  "Q",
  "DFN",
  "ABBR",
  "RUBY",
  "RB",
  "RT",
  "RTC",
  "RP",
  "DATA",
  "TIME",
  "CODE",
  "VAR",
  "SAMP",
  "KBD",
  "SUB",
  "SUP",
  "I",
  "B",
  "U",
  "MARK",
  "BDI",
  "BDO",
  "SPAN",
  "BR",
  "WBR",
  "INS",
  "DEL",
  "PICTURE",
  "PARAM",
  "TRACK",
  "MAP",
  "TABLE",
  "CAPTION",
  "COLGROUP",
  "COL",
  "TBODY",
  "THEAD",
  "TFOOT",
  "TR",
  "TD",
  "TH",
  "SELECT",
  "DATALIST",
  "OPTGROUP",
  "OPTION",
  "OUTPUT",
  "PROGRESS",
  "METER",
  "FIELDSET",
  "LEGEND",
  "DETAILS",
  "SUMMARY",
  "MENU",
  "DIALOG",
  "SLOT",
  "CANVAS",
  "FONT",
  "CENTER",
  "ACRONYM",
  "BASEFONT",
  "BIG",
  "DIR",
  "HGROUP",
  "STRIKE",
  "TT"
];
var ELEMENT_POLICIES = [
  [
    "A",
    /* @__PURE__ */ new Map([
      [
        "href",
        {
          policyAction: AttributePolicyAction.KEEP_AND_SANITIZE_URL
        }
      ]
    ])
  ],
  [
    "AREA",
    /* @__PURE__ */ new Map([
      [
        "href",
        {
          policyAction: AttributePolicyAction.KEEP_AND_SANITIZE_URL
        }
      ]
    ])
  ],
  [
    "LINK",
    /* @__PURE__ */ new Map([
      [
        "href",
        {
          policyAction: AttributePolicyAction.KEEP_AND_USE_RESOURCE_URL_POLICY,
          conditions: /* @__PURE__ */ new Map([
            [
              "rel",
              /* @__PURE__ */ new Set([
                "alternate",
                "author",
                "bookmark",
                "canonical",
                "cite",
                "help",
                "icon",
                "license",
                "next",
                "prefetch",
                "dns-prefetch",
                "prerender",
                "preconnect",
                "preload",
                "prev",
                "search",
                "subresource"
              ])
            ]
          ])
        }
      ]
    ])
  ],
  [
    "SOURCE",
    /* @__PURE__ */ new Map([
      [
        "src",
        {
          policyAction: AttributePolicyAction.KEEP_AND_USE_RESOURCE_URL_POLICY
        }
      ],
      [
        "srcset",
        {
          policyAction: AttributePolicyAction.KEEP_AND_USE_RESOURCE_URL_POLICY_FOR_SRCSET
        }
      ]
    ])
  ],
  [
    "IMG",
    /* @__PURE__ */ new Map([
      [
        "src",
        {
          policyAction: AttributePolicyAction.KEEP_AND_USE_RESOURCE_URL_POLICY
        }
      ],
      [
        "srcset",
        {
          policyAction: AttributePolicyAction.KEEP_AND_USE_RESOURCE_URL_POLICY_FOR_SRCSET
        }
      ]
    ])
  ],
  [
    "VIDEO",
    /* @__PURE__ */ new Map([
      [
        "src",
        {
          policyAction: AttributePolicyAction.KEEP_AND_USE_RESOURCE_URL_POLICY
        }
      ]
    ])
  ],
  [
    "AUDIO",
    /* @__PURE__ */ new Map([
      [
        "src",
        {
          policyAction: AttributePolicyAction.KEEP_AND_USE_RESOURCE_URL_POLICY
        }
      ]
    ])
  ]
];
var ALLOWED_GLOBAL_ATTRIBUTES = [
  "title",
  "aria-atomic",
  "aria-autocomplete",
  "aria-busy",
  "aria-checked",
  "aria-current",
  "aria-disabled",
  "aria-dropeffect",
  "aria-expanded",
  "aria-haspopup",
  "aria-hidden",
  "aria-invalid",
  "aria-label",
  "aria-level",
  "aria-live",
  "aria-multiline",
  "aria-multiselectable",
  "aria-orientation",
  "aria-posinset",
  "aria-pressed",
  "aria-readonly",
  "aria-relevant",
  "aria-required",
  "aria-selected",
  "aria-setsize",
  "aria-sort",
  "aria-valuemax",
  "aria-valuemin",
  "aria-valuenow",
  "aria-valuetext",
  "alt",
  "align",
  "autocapitalize",
  "autocomplete",
  "autocorrect",
  "autofocus",
  "autoplay",
  "bgcolor",
  "border",
  "cellpadding",
  "cellspacing",
  "checked",
  "color",
  "cols",
  "colspan",
  "controls",
  "datetime",
  "disabled",
  "download",
  "draggable",
  "enctype",
  "face",
  "formenctype",
  "frameborder",
  "height",
  "hreflang",
  "hidden",
  "ismap",
  "label",
  "lang",
  "loop",
  "max",
  "maxlength",
  "media",
  "minlength",
  "min",
  "multiple",
  "muted",
  "nonce",
  "open",
  "placeholder",
  "preload",
  "rel",
  "required",
  "reversed",
  "role",
  "rows",
  "rowspan",
  "selected",
  "shape",
  "size",
  "sizes",
  "slot",
  "span",
  "spellcheck",
  "start",
  "step",
  "summary",
  "translate",
  "type",
  "valign",
  "value",
  "width",
  "wrap",
  "itemscope",
  "itemtype",
  "itemid",
  "itemprop",
  "itemref"
];
var GLOBAL_ATTRIBUTE_POLICIES = [
  [
    "dir",
    {
      policyAction: AttributePolicyAction.KEEP_AND_NORMALIZE,
      conditions: pure(() => {
        return /* @__PURE__ */ new Map([
          ["dir", /* @__PURE__ */ new Set(["auto", "ltr", "rtl"])]
        ]);
      })
    }
  ],
  [
    "async",
    {
      policyAction: AttributePolicyAction.KEEP_AND_NORMALIZE,
      conditions: pure(() => {
        return /* @__PURE__ */ new Map([
          ["async", /* @__PURE__ */ new Set(["async"])]
        ]);
      })
    }
  ],
  [
    "cite",
    {
      policyAction: AttributePolicyAction.KEEP_AND_SANITIZE_URL
    }
  ],
  [
    "loading",
    {
      policyAction: AttributePolicyAction.KEEP_AND_NORMALIZE,
      conditions: pure(() => {
        return /* @__PURE__ */ new Map([
          ["loading", /* @__PURE__ */ new Set(["eager", "lazy"])]
        ]);
      })
    }
  ],
  [
    "poster",
    {
      policyAction: AttributePolicyAction.KEEP_AND_SANITIZE_URL
    }
  ],
  [
    "target",
    {
      policyAction: AttributePolicyAction.KEEP_AND_NORMALIZE,
      conditions: pure(() => {
        return /* @__PURE__ */ new Map([
          ["target", /* @__PURE__ */ new Set(["_self", "_blank"])]
        ]);
      })
    }
  ]
];
var DEFAULT_SANITIZER_TABLE = new SanitizerTable(new Set(ALLOWED_ELEMENTS), new Map(ELEMENT_POLICIES), new Set(ALLOWED_GLOBAL_ATTRIBUTES), new Map(GLOBAL_ATTRIBUTE_POLICIES));
var CSS_SANITIZER_TABLE = new SanitizerTable(
  new Set(pure(() => ALLOWED_ELEMENTS.concat(["STYLE"]))),
  new Map(ELEMENT_POLICIES),
  // We allow id, name, and class because they can be used in CSS selectors.
  // Shadow DOM ensures that those names don't clash with other names in the
  // document.
  new Set(
    pure(() => ALLOWED_GLOBAL_ATTRIBUTES.concat(["id", "name", "class"]))
  ),
  new Map(
    pure(() => GLOBAL_ATTRIBUTE_POLICIES.concat([
      [
        "style",
        { policyAction: AttributePolicyAction.KEEP_AND_SANITIZE_STYLE }
      ]
    ]))
  )
);

// node_modules/safevalues/dist/mjs/builders/html_sanitizer/html_sanitizer.js
var HtmlSanitizerImpl = class {
  constructor(sanitizerTable, token, styleElementSanitizer, styleAttributeSanitizer, resourceUrlPolicy) {
    this.sanitizerTable = sanitizerTable;
    this.styleElementSanitizer = styleElementSanitizer;
    this.styleAttributeSanitizer = styleAttributeSanitizer;
    this.resourceUrlPolicy = resourceUrlPolicy;
    this.changes = [];
    ensureTokenIsValid(token);
  }
  sanitizeAssertUnchanged(html) {
    if (true) {
      this.changes = [];
    }
    const sanitizedHtml = this.sanitize(html);
    if (this.changes.length !== 0) {
      throw new Error(`Unexpected change to HTML value as a result of sanitization. Input: "${html}", sanitized output: "${sanitizedHtml}"
List of changes:${this.changes.join("\n")}`);
    }
    return sanitizedHtml;
  }
  sanitize(html) {
    const inertDocument = document.implementation.createHTMLDocument("");
    return nodeToHtmlInternal(this.sanitizeToFragmentInternal(html, inertDocument), inertDocument.body);
  }
  sanitizeToFragment(html) {
    const inertDocument = document.implementation.createHTMLDocument("");
    return this.sanitizeToFragmentInternal(html, inertDocument);
  }
  sanitizeToFragmentInternal(html, inertDocument) {
    const dirtyFragment = createInertFragment(html, inertDocument);
    const treeWalker = document.createTreeWalker(dirtyFragment, 5, (n) => this.nodeFilter(n));
    let currentNode = treeWalker.nextNode();
    const sanitizedFragment = inertDocument.createDocumentFragment();
    let sanitizedParent = sanitizedFragment;
    while (currentNode !== null) {
      let sanitizedNode;
      if (isText(currentNode)) {
        if (this.styleElementSanitizer && sanitizedParent.nodeName === "STYLE") {
          const sanitizedCss = this.styleElementSanitizer(currentNode.data);
          sanitizedNode = this.createTextNode(sanitizedCss);
        } else {
          sanitizedNode = this.sanitizeTextNode(currentNode);
        }
      } else if (isElement(currentNode)) {
        sanitizedNode = this.sanitizeElementNode(currentNode, inertDocument);
      } else {
        let message = "";
        if (true) {
          message = "Node is not of type text or element";
        }
        throw new Error(message);
      }
      sanitizedParent.appendChild(sanitizedNode);
      currentNode = treeWalker.firstChild();
      if (currentNode) {
        sanitizedParent = sanitizedNode;
      } else {
        while (!(currentNode = treeWalker.nextSibling())) {
          if (!(currentNode = treeWalker.parentNode())) {
            break;
          }
          sanitizedParent = sanitizedParent.parentNode;
        }
      }
    }
    return sanitizedFragment;
  }
  createTextNode(text) {
    return document.createTextNode(text);
  }
  sanitizeTextNode(textNode) {
    return this.createTextNode(textNode.data);
  }
  sanitizeElementNode(elementNode, inertDocument) {
    const elementName = getNodeName(elementNode);
    const newNode = inertDocument.createElement(elementName);
    const dirtyAttributes = elementNode.attributes;
    for (const { name: name3, value } of dirtyAttributes) {
      const policy = this.sanitizerTable.getAttributePolicy(name3, elementName);
      if (!this.satisfiesAllConditions(policy.conditions, dirtyAttributes)) {
        this.recordChange(`Not all conditions satisfied for attribute: ${name3}.`);
        continue;
      }
      switch (policy.policyAction) {
        case AttributePolicyAction.KEEP:
          setAttribute(newNode, name3, value);
          break;
        case AttributePolicyAction.KEEP_AND_SANITIZE_URL:
          const sanitizedAttrUrl = restrictivelySanitizeUrl(value);
          if (sanitizedAttrUrl !== value) {
            this.recordChange(`Url in attribute ${name3} was modified during sanitization. Original url:"${value}" was sanitized to: "${sanitizedAttrUrl}"`);
          }
          setAttribute(newNode, name3, sanitizedAttrUrl);
          break;
        case AttributePolicyAction.KEEP_AND_NORMALIZE:
          setAttribute(newNode, name3, value.toLowerCase());
          break;
        case AttributePolicyAction.KEEP_AND_SANITIZE_STYLE:
          if (this.styleAttributeSanitizer) {
            const sanitizedCss = this.styleAttributeSanitizer(value);
            setAttribute(newNode, name3, sanitizedCss);
          } else {
            setAttribute(newNode, name3, value);
          }
          break;
        case AttributePolicyAction.KEEP_AND_USE_RESOURCE_URL_POLICY:
          if (this.resourceUrlPolicy) {
            const hints = {
              type: ResourceUrlPolicyHintsType.HTML_ATTRIBUTE,
              attributeName: name3,
              tagName: elementName
            };
            const url = parseUrl(value);
            const sanitizedUrl = this.resourceUrlPolicy(url, hints);
            if (sanitizedUrl) {
              setAttribute(newNode, name3, sanitizedUrl.toString());
            }
          } else {
            setAttribute(newNode, name3, value);
          }
          break;
        case AttributePolicyAction.KEEP_AND_USE_RESOURCE_URL_POLICY_FOR_SRCSET:
          if (this.resourceUrlPolicy) {
            const hints = {
              type: ResourceUrlPolicyHintsType.HTML_ATTRIBUTE,
              attributeName: name3,
              tagName: elementName
            };
            const srcset = parseSrcset(value);
            const sanitizedSrcset = { parts: [] };
            for (const part of srcset.parts) {
              const url = parseUrl(part.url);
              const sanitizedUrl = this.resourceUrlPolicy(url, hints);
              if (sanitizedUrl) {
                sanitizedSrcset.parts.push({
                  url: sanitizedUrl.toString(),
                  descriptor: part.descriptor
                });
              }
            }
            setAttribute(newNode, name3, serializeSrcset(sanitizedSrcset));
          } else {
            setAttribute(newNode, name3, value);
          }
          break;
        case AttributePolicyAction.DROP:
          this.recordChange(`Attribute: ${name3} was dropped`);
          break;
        default:
          if (true) {
            checkExhaustive(policy.policyAction, "Unhandled AttributePolicyAction case");
          }
      }
    }
    return newNode;
  }
  nodeFilter(node) {
    if (isText(node)) {
      return 1;
    } else if (!isElement(node)) {
      return 2;
    }
    const nodeName = getNodeName(node);
    if (nodeName === null) {
      this.recordChange(`Node name was null for node: ${node}`);
      return 2;
    }
    if (this.sanitizerTable.isAllowedElement(nodeName)) {
      return 1;
    }
    this.recordChange(`Element: ${nodeName} was dropped`);
    return 2;
  }
  recordChange(errorMessage) {
    if (true) {
      this.changes.push(errorMessage);
    }
  }
  satisfiesAllConditions(conditions, attrs) {
    var _a;
    if (!conditions) {
      return true;
    }
    for (const [attrName, expectedValues] of conditions) {
      const value = (_a = attrs.getNamedItem(attrName)) === null || _a === void 0 ? void 0 : _a.value;
      if (value && !expectedValues.has(value)) {
        return false;
      }
    }
    return true;
  }
};
function setAttribute(el, name3, value) {
  el.setAttribute(name3, value);
}
function parseSrcset(srcset) {
  const parts = [];
  for (const part of srcset.split(",")) {
    const [url, descriptor] = part.trim().split(/\s+/, 2);
    parts.push({ url, descriptor });
  }
  return { parts };
}
function serializeSrcset(srcset) {
  return srcset.parts.map((part) => {
    const { url, descriptor } = part;
    return `${url}${descriptor ? ` ${descriptor}` : ""}`;
  }).join(" , ");
}
var defaultHtmlSanitizer = pure(() => new HtmlSanitizerImpl(DEFAULT_SANITIZER_TABLE, secretToken));
function checkExhaustive(value, msg = `unexpected value ${value}!`) {
  throw new Error(msg);
}

// node_modules/safevalues/dist/mjs/builders/resource_url_builders.js
function hasValidOrigin(base) {
  if (!(/^https:\/\//.test(base) || /^\/\//.test(base))) {
    return false;
  }
  const originStart = base.indexOf("//") + 2;
  const originEnd = base.indexOf("/", originStart);
  if (originEnd <= originStart) {
    throw new Error(`Can't interpolate data in a url's origin, Please make sure to fully specify the origin, terminated with '/'.`);
  }
  const origin = base.substring(originStart, originEnd);
  if (!/^[0-9a-z.:-]+$/i.test(origin)) {
    throw new Error("The origin contains unsupported characters.");
  }
  if (!/^[^:]*(:[0-9]+)?$/i.test(origin)) {
    throw new Error("Invalid port number.");
  }
  if (!/(^|\.)[a-z][^.]*$/i.test(origin)) {
    throw new Error("The top-level domain must start with a letter.");
  }
  return true;
}
function isValidAboutUrl(base) {
  if (!/^about:blank/.test(base)) {
    return false;
  }
  if (base !== "about:blank" && !/^about:blank#/.test(base)) {
    throw new Error("The about url is invalid.");
  }
  return true;
}
function isValidPathStart(base) {
  if (!/^\//.test(base)) {
    return false;
  }
  if (base === "/" || base.length > 1 && base[1] !== "/" && base[1] !== "\\") {
    return true;
  }
  throw new Error("The path start in the url is invalid.");
}
function isValidRelativePathStart(base) {
  return new RegExp("^[^:\\s\\\\/]+/").test(base);
}
function trustedResourceUrl(templateObj, ...rest) {
  if (true) {
    assertIsTemplateObject(templateObj, rest.length);
  }
  if (rest.length === 0) {
    return createResourceUrlInternal(templateObj[0]);
  }
  const base = templateObj[0].toLowerCase();
  if (true) {
    if (/^data:/.test(base)) {
      throw new Error("Data URLs cannot have expressions in the template literal input.");
    }
    if (!hasValidOrigin(base) && !isValidPathStart(base) && !isValidRelativePathStart(base) && !isValidAboutUrl(base)) {
      throw new Error("Trying to interpolate expressions in an unsupported url format.");
    }
  }
  let url = templateObj[0];
  for (let i = 0; i < rest.length; i++) {
    url += encodeURIComponent(rest[i]) + templateObj[i + 1];
  }
  return createResourceUrlInternal(url);
}

// node_modules/safevalues/dist/mjs/internals/style_sheet_impl.js
var SafeStyleSheet = class {
};
var StyleSheetImpl = class extends SafeStyleSheet {
  constructor(styleSheet, token) {
    super();
    ensureTokenIsValid(token);
    this.privateDoNotAccessOrElseWrappedStyleSheet = styleSheet;
  }
  toString() {
    return this.privateDoNotAccessOrElseWrappedStyleSheet;
  }
};
function createStyleSheetInternal(styleSheet) {
  return new StyleSheetImpl(styleSheet, secretToken);
}
function unwrapStyleSheet(value) {
  if (value instanceof StyleSheetImpl) {
    return value.privateDoNotAccessOrElseWrappedStyleSheet;
  } else {
    let message = "";
    if (true) {
      message = "Unexpected type when unwrapping SafeStyleSheet";
    }
    throw new Error(message);
  }
}

// node_modules/safevalues/dist/mjs/dom/elements/anchor.js
var anchor_exports = {};
__export(anchor_exports, {
  setHref: () => setHref
});
function setHref(anchor, url) {
  const sanitizedUrl = unwrapUrlOrSanitize(url);
  if (sanitizedUrl !== void 0) {
    anchor.href = sanitizedUrl;
  }
}

// node_modules/safevalues/dist/mjs/dom/elements/area.js
var area_exports = {};
__export(area_exports, {
  setHref: () => setHref2
});
function setHref2(area, url) {
  const sanitizedUrl = unwrapUrlOrSanitize(url);
  if (sanitizedUrl !== void 0) {
    area.href = sanitizedUrl;
  }
}

// node_modules/safevalues/dist/mjs/dom/elements/base.js
var base_exports = {};
__export(base_exports, {
  setHref: () => setHref3
});
function setHref3(baseEl, url) {
  baseEl.href = unwrapResourceUrl(url);
}

// node_modules/safevalues/dist/mjs/dom/elements/button.js
var button_exports = {};
__export(button_exports, {
  setFormaction: () => setFormaction
});
function setFormaction(button, url) {
  const sanitizedUrl = unwrapUrlOrSanitize(url);
  if (sanitizedUrl !== void 0) {
    button.formAction = sanitizedUrl;
  }
}

// node_modules/safevalues/dist/mjs/dom/elements/element.js
var element_exports = {};
__export(element_exports, {
  buildPrefixedAttributeSetter: () => buildPrefixedAttributeSetter,
  insertAdjacentHtml: () => insertAdjacentHtml,
  setInnerHtml: () => setInnerHtml,
  setOuterHtml: () => setOuterHtml,
  setPrefixedAttribute: () => setPrefixedAttribute
});
function setInnerHtml(elOrRoot, v) {
  if (isElement2(elOrRoot)) {
    throwIfScriptOrStyle(elOrRoot);
  }
  elOrRoot.innerHTML = unwrapHtml(v);
}
function setOuterHtml(e, v) {
  const parent = e.parentElement;
  if (parent !== null) {
    throwIfScriptOrStyle(parent);
  }
  e.outerHTML = unwrapHtml(v);
}
function insertAdjacentHtml(element, position, v) {
  const tagContext = position === "beforebegin" || position === "afterend" ? element.parentElement : element;
  if (tagContext !== null) {
    throwIfScriptOrStyle(tagContext);
  }
  element.insertAdjacentHTML(position, unwrapHtml(v));
}
function buildPrefixedAttributeSetter(prefix, ...otherPrefixes) {
  const prefixes = [prefix, ...otherPrefixes];
  return (e, attr, value) => {
    setPrefixedAttribute(prefixes, e, attr, value);
  };
}
function setPrefixedAttribute(attrPrefixes, e, attr, value) {
  if (attrPrefixes.length === 0) {
    let message = "";
    if (true) {
      message = "No prefixes are provided";
    }
    throw new Error(message);
  }
  const prefixes = attrPrefixes.map((s) => unwrapAttributePrefix(s));
  const attrLower = attr.toLowerCase();
  if (prefixes.every((p) => attrLower.indexOf(p) !== 0)) {
    throw new Error(`Attribute "${attr}" does not match any of the allowed prefixes.`);
  }
  e.setAttribute(attr, value);
}
function throwIfScriptOrStyle(element) {
  let message = "";
  const tagName = element.tagName;
  if (tagName === "SCRIPT" || tagName === "STYLE") {
    if (true) {
      if (tagName === "SCRIPT") {
        message = "Use safeScriptEl.setTextContent with a SafeScript.";
      } else {
        message = "Use safeStyleEl.setTextContent with a SafeStyleSheet.";
      }
    }
    throw new Error(message);
  }
}
function isElement2(elOrRoot) {
  return elOrRoot.nodeType === 1;
}

// node_modules/safevalues/dist/mjs/dom/elements/embed.js
var embed_exports = {};
__export(embed_exports, {
  setSrc: () => setSrc
});
function setSrc(embedEl, url) {
  embedEl.src = unwrapResourceUrl(url);
}

// node_modules/safevalues/dist/mjs/dom/elements/form.js
var form_exports = {};
__export(form_exports, {
  setAction: () => setAction
});
function setAction(form, url) {
  const sanitizedUrl = unwrapUrlOrSanitize(url);
  if (sanitizedUrl !== void 0) {
    form.action = sanitizedUrl;
  }
}

// node_modules/safevalues/dist/mjs/dom/elements/iframe.js
var iframe_exports = {};
__export(iframe_exports, {
  setSrc: () => setSrc2,
  setSrcdoc: () => setSrcdoc
});
function setSrc2(iframe, v) {
  iframe.src = unwrapResourceUrl(v).toString();
}
function setSrcdoc(iframe, v) {
  iframe.srcdoc = unwrapHtml(v);
}

// node_modules/safevalues/dist/mjs/dom/elements/input.js
var input_exports = {};
__export(input_exports, {
  setFormaction: () => setFormaction2
});
function setFormaction2(input, url) {
  const sanitizedUrl = unwrapUrlOrSanitize(url);
  if (sanitizedUrl !== void 0) {
    input.formAction = sanitizedUrl;
  }
}

// node_modules/safevalues/dist/mjs/dom/elements/link.js
var link_exports = {};
__export(link_exports, {
  setHrefAndRel: () => setHrefAndRel,
  setHrefAndRelWithTrustedResourceUrl: () => setHrefAndRelWithTrustedResourceUrl
});
var SAFE_URL_REL_VALUES = [
  "alternate",
  "author",
  "bookmark",
  "canonical",
  "cite",
  "help",
  "icon",
  "license",
  "modulepreload",
  "next",
  "prefetch",
  "dns-prefetch",
  "prerender",
  "preconnect",
  "preload",
  "prev",
  "search",
  "subresource"
];
function setHrefAndRel(link, url, rel) {
  if (isResourceUrl(url)) {
    setHrefAndRelWithTrustedResourceUrl(link, url, rel);
    return;
  } else {
    if (SAFE_URL_REL_VALUES.indexOf(rel) === -1) {
      throw new Error(`TrustedResourceUrl href attribute required with rel="${rel}"`);
    }
    const sanitizedUrl = unwrapUrlOrSanitize(url);
    if (sanitizedUrl === void 0) {
      return;
    }
    link.href = sanitizedUrl;
  }
  link.rel = rel;
}
function setHrefAndRelWithTrustedResourceUrl(link, url, rel) {
  link.href = unwrapResourceUrl(url).toString();
  link.rel = rel;
}

// node_modules/safevalues/dist/mjs/dom/elements/object.js
var object_exports = {};
__export(object_exports, {
  setData: () => setData
});
function setData(obj, v) {
  obj.data = unwrapResourceUrl(v);
}

// node_modules/safevalues/dist/mjs/dom/elements/script.js
var script_exports = {};
__export(script_exports, {
  setSrc: () => setSrc3,
  setTextContent: () => setTextContent
});

// node_modules/safevalues/dist/mjs/dom/globals/window.js
var window_exports = {};
__export(window_exports, {
  getScriptNonce: () => getScriptNonce,
  getStyleNonce: () => getStyleNonce,
  open: () => open
});
function open(win, url, target, features) {
  const sanitizedUrl = unwrapUrlOrSanitize(url);
  if (sanitizedUrl !== void 0) {
    return win.open(sanitizedUrl, target, features);
  }
  return null;
}
function getScriptNonce(win) {
  return getNonceFor("script", win);
}
function getStyleNonce(win) {
  return getNonceFor("style", win);
}
function getNonceFor(elementName, win) {
  var _a;
  const doc = win.document;
  const el = (_a = doc.querySelector) === null || _a === void 0 ? void 0 : _a.call(doc, `${elementName}[nonce]`);
  if (el) {
    return el["nonce"] || el.getAttribute("nonce") || "";
  }
  return "";
}

// node_modules/safevalues/dist/mjs/dom/elements/script.js
function setNonceForScriptElement(script) {
  const win = script.ownerDocument && script.ownerDocument.defaultView;
  const nonce = getScriptNonce(win || window);
  if (nonce) {
    script.setAttribute("nonce", nonce);
  }
}
function setTextContent(script, v, options) {
  script.textContent = unwrapScript(v);
  if (options === null || options === void 0 ? void 0 : options.omitNonce)
    return;
  setNonceForScriptElement(script);
}
function setSrc3(script, v, options) {
  script.src = unwrapResourceUrl(v);
  if (options === null || options === void 0 ? void 0 : options.omitNonce)
    return;
  setNonceForScriptElement(script);
}

// node_modules/safevalues/dist/mjs/dom/elements/style.js
var style_exports = {};
__export(style_exports, {
  setTextContent: () => setTextContent2
});
function setTextContent2(elem, safeStyleSheet2) {
  elem.textContent = unwrapStyleSheet(safeStyleSheet2);
}

// node_modules/safevalues/dist/mjs/dom/elements/svg.js
var svg_exports = {};
__export(svg_exports, {
  setAttribute: () => setAttribute2
});
var UNSAFE_SVG_ATTRIBUTES = ["href", "xlink:href"];
function setAttribute2(svg, attr, value) {
  const attrLower = attr.toLowerCase();
  if (UNSAFE_SVG_ATTRIBUTES.indexOf(attrLower) !== -1 || attrLower.indexOf("on") === 0) {
    let msg = "";
    if (true) {
      msg = `Setting the '${attrLower}' attribute on SVG can cause XSS.`;
    }
    throw new Error(msg);
  }
  svg.setAttribute(attr, value);
}

// node_modules/safevalues/dist/mjs/dom/elements/svg_use.js
var svg_use_exports = {};
__export(svg_use_exports, {
  setHref: () => setHref4
});
function setHref4(useEl, url) {
  const scheme = extractScheme(url);
  if (scheme === "javascript:" || scheme === "data:") {
    if (true) {
      const msg = `A URL with content '${url}' was sanitized away.`;
      console.error(msg);
    }
    return;
  }
  useEl.setAttribute("href", url);
}

// node_modules/safevalues/dist/mjs/dom/globals/document.js
var document_exports = {};
__export(document_exports, {
  execCommand: () => execCommand,
  execCommandInsertHtml: () => execCommandInsertHtml,
  write: () => write
});
function write(doc, text) {
  doc.write(unwrapHtml(text));
}
function execCommand(doc, command, value) {
  const commandString = String(command);
  let valueArgument = value;
  if (commandString.toLowerCase() === "inserthtml") {
    valueArgument = unwrapHtml(value);
  }
  return doc.execCommand(
    commandString,
    /* showUi= */
    false,
    valueArgument
  );
}
function execCommandInsertHtml(doc, html) {
  return doc.execCommand(
    "insertHTML",
    /* showUi= */
    false,
    unwrapHtml(html)
  );
}

// node_modules/safevalues/dist/mjs/dom/globals/dom_parser.js
var dom_parser_exports = {};
__export(dom_parser_exports, {
  parseFromString: () => parseFromString,
  parseHtml: () => parseHtml,
  parseXml: () => parseXml
});
function parseHtml(parser, html) {
  return parseFromString(parser, html, "text/html");
}
function parseXml(parser, xml) {
  const doc = parseFromString(parser, createHtmlInternal(xml), "text/xml");
  const iterator = document.createNodeIterator(doc, NodeFilter.SHOW_ALL);
  let currentNode;
  while (currentNode = iterator.nextNode()) {
    if (currentNode instanceof HTMLElement || currentNode instanceof SVGElement) {
      let message = "unsafe XML";
      if (true) {
        message = `attempted to parse an XML document that embeds HTML or SVG content`;
      }
      throw new Error(message);
    }
  }
  return doc;
}
function parseFromString(parser, content, contentType) {
  return parser.parseFromString(unwrapHtml(content), contentType);
}

// node_modules/safevalues/dist/mjs/dom/globals/global.js
var global_exports = {};
__export(global_exports, {
  fetchResourceUrl: () => fetchResourceUrl,
  globalEval: () => globalEval
});

// node_modules/safevalues/dist/mjs/dom/globals/fetch.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var IncorrectContentTypeError = class extends Error {
  constructor(url, typeName, contentType) {
    super(`${url} was requested as a ${typeName}, but the response Content-Type, "${contentType} is not appropriate for this type of content.`);
    this.url = url;
    this.typeName = typeName;
    this.contentType = contentType;
  }
};
function privatecreateHtmlInternal(html) {
  return createHtmlInternal(html);
}
function fetchResourceUrl(u, init) {
  var _a, _b, _c;
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield fetch(unwrapResourceUrl(u).toString(), init);
    const mimeType = (_c = (_b = (_a = response.headers.get("Content-Type")) === null || _a === void 0 ? void 0 : _a.split(";", 2)) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.toLowerCase();
    return {
      html() {
        return __awaiter(this, void 0, void 0, function* () {
          if (mimeType !== "text/html") {
            throw new IncorrectContentTypeError(response.url, "SafeHtml", "text/html");
          }
          const text = yield response.text();
          return privatecreateHtmlInternal(text);
        });
      },
      script() {
        return __awaiter(this, void 0, void 0, function* () {
          if (mimeType !== "text/javascript" && mimeType !== "application/javascript") {
            throw new IncorrectContentTypeError(response.url, "SafeScript", "text/javascript");
          }
          const text = yield response.text();
          return createScriptInternal(text);
        });
      },
      styleSheet() {
        return __awaiter(this, void 0, void 0, function* () {
          if (mimeType !== "text/css") {
            throw new IncorrectContentTypeError(response.url, "SafeStyleSheet", "text/css");
          }
          const text = yield response.text();
          return createStyleSheetInternal(text);
        });
      }
    };
  });
}

// node_modules/safevalues/dist/mjs/dom/globals/global.js
function globalEval(win, script) {
  const trustedScript = unwrapScript(script);
  let result = win.eval(trustedScript);
  if (result === trustedScript) {
    result = win.eval(trustedScript.toString());
  }
  return result;
}

// node_modules/safevalues/dist/mjs/dom/globals/location.js
var location_exports = {};
__export(location_exports, {
  assign: () => assign,
  replace: () => replace,
  setHref: () => setHref5
});
function setHref5(loc, url) {
  const sanitizedUrl = unwrapUrlOrSanitize(url);
  if (sanitizedUrl !== void 0) {
    loc.href = sanitizedUrl;
  }
}
function replace(loc, url) {
  const sanitizedUrl = unwrapUrlOrSanitize(url);
  if (sanitizedUrl !== void 0) {
    loc.replace(sanitizedUrl);
  }
}
function assign(loc, url) {
  const sanitizedUrl = unwrapUrlOrSanitize(url);
  if (sanitizedUrl !== void 0) {
    loc.assign(sanitizedUrl);
  }
}

// node_modules/safevalues/dist/mjs/dom/globals/service_worker_container.js
var service_worker_container_exports = {};
__export(service_worker_container_exports, {
  register: () => register
});
function register(container, scriptURL, options) {
  return container.register(unwrapResourceUrl(scriptURL), options);
}

// node_modules/safevalues/dist/mjs/dom/globals/url.js
var url_exports = {};
__export(url_exports, {
  objectUrlFromSafeSource: () => objectUrlFromSafeSource
});
function isSafeMimeType(mimeType) {
  const match = mimeType.match(/^([^;]+)(?:;\w+=(?:\w+|"[\w;,= ]+"))*$/i);
  return (match === null || match === void 0 ? void 0 : match.length) === 2 && (isSafeImageMimeType(match[1]) || isSafeVideoMimeType(match[1]) || isSafeAudioMimeType(match[1]));
}
function isSafeImageMimeType(mimeType) {
  return /^image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp|x-icon|heic|heif)$/i.test(mimeType);
}
function isSafeVideoMimeType(mimeType) {
  return /^video\/(?:mpeg|mp4|ogg|webm|x-matroska|quicktime|x-ms-wmv)$/i.test(mimeType);
}
function isSafeAudioMimeType(mimeType) {
  return /^audio\/(?:3gpp2|3gpp|aac|L16|midi|mp3|mp4|mpeg|oga|ogg|opus|x-m4a|x-matroska|x-wav|wav|webm)$/i.test(mimeType);
}
function objectUrlFromSafeSource(source) {
  if (typeof MediaSource !== "undefined" && source instanceof MediaSource) {
    return URL.createObjectURL(source);
  }
  const blob = source;
  if (!isSafeMimeType(blob.type)) {
    let message = "";
    if (true) {
      message = `unsafe blob MIME type: ${blob.type}`;
    }
    throw new Error(message);
  }
  return URL.createObjectURL(blob);
}

// node_modules/safevalues/dist/mjs/dom/globals/worker.js
var worker_exports = {};
__export(worker_exports, {
  create: () => create,
  createShared: () => createShared,
  importScripts: () => importScripts
});
function create(url, options) {
  return new Worker(unwrapResourceUrl(url), options);
}
function createShared(url, options) {
  return new SharedWorker(unwrapResourceUrl(url), options);
}
function importScripts(scope, ...urls) {
  scope.importScripts(...urls.map((url) => unwrapResourceUrl(url)));
}

// node_modules/@firebase/installations/dist/esm/index.esm2017.js
var name = "@firebase/installations";
var version = "0.6.8";
var PENDING_TIMEOUT_MS = 1e4;
var PACKAGE_VERSION = `w:${version}`;
var INTERNAL_AUTH_VERSION = "FIS_v2";
var INSTALLATIONS_API_URL = "https://firebaseinstallations.googleapis.com/v1";
var TOKEN_EXPIRATION_BUFFER = 60 * 60 * 1e3;
var SERVICE = "installations";
var SERVICE_NAME = "Installations";
var ERROR_DESCRIPTION_MAP = {
  [
    "missing-app-config-values"
    /* ErrorCode.MISSING_APP_CONFIG_VALUES */
  ]: 'Missing App configuration value: "{$valueName}"',
  [
    "not-registered"
    /* ErrorCode.NOT_REGISTERED */
  ]: "Firebase Installation is not registered.",
  [
    "installation-not-found"
    /* ErrorCode.INSTALLATION_NOT_FOUND */
  ]: "Firebase Installation not found.",
  [
    "request-failed"
    /* ErrorCode.REQUEST_FAILED */
  ]: '{$requestName} request failed with error "{$serverCode} {$serverStatus}: {$serverMessage}"',
  [
    "app-offline"
    /* ErrorCode.APP_OFFLINE */
  ]: "Could not process request. Application offline.",
  [
    "delete-pending-registration"
    /* ErrorCode.DELETE_PENDING_REGISTRATION */
  ]: "Can't delete installation while there is a pending registration request."
};
var ERROR_FACTORY = new ErrorFactory(SERVICE, SERVICE_NAME, ERROR_DESCRIPTION_MAP);
function isServerError(error) {
  return error instanceof FirebaseError && error.code.includes(
    "request-failed"
    /* ErrorCode.REQUEST_FAILED */
  );
}
function getInstallationsEndpoint({ projectId }) {
  return `${INSTALLATIONS_API_URL}/projects/${projectId}/installations`;
}
function extractAuthTokenInfoFromResponse(response) {
  return {
    token: response.token,
    requestStatus: 2,
    expiresIn: getExpiresInFromResponseExpiresIn(response.expiresIn),
    creationTime: Date.now()
  };
}
async function getErrorFromResponse(requestName, response) {
  const responseJson = await response.json();
  const errorData = responseJson.error;
  return ERROR_FACTORY.create("request-failed", {
    requestName,
    serverCode: errorData.code,
    serverMessage: errorData.message,
    serverStatus: errorData.status
  });
}
function getHeaders({ apiKey }) {
  return new Headers({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-goog-api-key": apiKey
  });
}
function getHeadersWithAuth(appConfig, { refreshToken }) {
  const headers = getHeaders(appConfig);
  headers.append("Authorization", getAuthorizationHeader(refreshToken));
  return headers;
}
async function retryIfServerError(fn) {
  const result = await fn();
  if (result.status >= 500 && result.status < 600) {
    return fn();
  }
  return result;
}
function getExpiresInFromResponseExpiresIn(responseExpiresIn) {
  return Number(responseExpiresIn.replace("s", "000"));
}
function getAuthorizationHeader(refreshToken) {
  return `${INTERNAL_AUTH_VERSION} ${refreshToken}`;
}
async function createInstallationRequest({ appConfig, heartbeatServiceProvider }, { fid }) {
  const endpoint = getInstallationsEndpoint(appConfig);
  const headers = getHeaders(appConfig);
  const heartbeatService = heartbeatServiceProvider.getImmediate({
    optional: true
  });
  if (heartbeatService) {
    const heartbeatsHeader = await heartbeatService.getHeartbeatsHeader();
    if (heartbeatsHeader) {
      headers.append("x-firebase-client", heartbeatsHeader);
    }
  }
  const body = {
    fid,
    authVersion: INTERNAL_AUTH_VERSION,
    appId: appConfig.appId,
    sdkVersion: PACKAGE_VERSION
  };
  const request = {
    method: "POST",
    headers,
    body: JSON.stringify(body)
  };
  const response = await retryIfServerError(() => fetch(endpoint, request));
  if (response.ok) {
    const responseValue = await response.json();
    const registeredInstallationEntry = {
      fid: responseValue.fid || fid,
      registrationStatus: 2,
      refreshToken: responseValue.refreshToken,
      authToken: extractAuthTokenInfoFromResponse(responseValue.authToken)
    };
    return registeredInstallationEntry;
  } else {
    throw await getErrorFromResponse("Create Installation", response);
  }
}
function sleep(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}
function bufferToBase64UrlSafe(array) {
  const b64 = btoa(String.fromCharCode(...array));
  return b64.replace(/\+/g, "-").replace(/\//g, "_");
}
var VALID_FID_PATTERN = /^[cdef][\w-]{21}$/;
var INVALID_FID = "";
function generateFid() {
  try {
    const fidByteArray = new Uint8Array(17);
    const crypto = self.crypto || self.msCrypto;
    crypto.getRandomValues(fidByteArray);
    fidByteArray[0] = 112 + fidByteArray[0] % 16;
    const fid = encode(fidByteArray);
    return VALID_FID_PATTERN.test(fid) ? fid : INVALID_FID;
  } catch (_a) {
    return INVALID_FID;
  }
}
function encode(fidByteArray) {
  const b64String = bufferToBase64UrlSafe(fidByteArray);
  return b64String.substr(0, 22);
}
function getKey(appConfig) {
  return `${appConfig.appName}!${appConfig.appId}`;
}
var fidChangeCallbacks = /* @__PURE__ */ new Map();
function fidChanged(appConfig, fid) {
  const key = getKey(appConfig);
  callFidChangeCallbacks(key, fid);
  broadcastFidChange(key, fid);
}
function callFidChangeCallbacks(key, fid) {
  const callbacks = fidChangeCallbacks.get(key);
  if (!callbacks) {
    return;
  }
  for (const callback of callbacks) {
    callback(fid);
  }
}
function broadcastFidChange(key, fid) {
  const channel = getBroadcastChannel();
  if (channel) {
    channel.postMessage({ key, fid });
  }
  closeBroadcastChannel();
}
var broadcastChannel = null;
function getBroadcastChannel() {
  if (!broadcastChannel && "BroadcastChannel" in self) {
    broadcastChannel = new BroadcastChannel("[Firebase] FID Change");
    broadcastChannel.onmessage = (e) => {
      callFidChangeCallbacks(e.data.key, e.data.fid);
    };
  }
  return broadcastChannel;
}
function closeBroadcastChannel() {
  if (fidChangeCallbacks.size === 0 && broadcastChannel) {
    broadcastChannel.close();
    broadcastChannel = null;
  }
}
var DATABASE_NAME = "firebase-installations-database";
var DATABASE_VERSION = 1;
var OBJECT_STORE_NAME = "firebase-installations-store";
var dbPromise = null;
function getDbPromise() {
  if (!dbPromise) {
    dbPromise = openDB(DATABASE_NAME, DATABASE_VERSION, {
      upgrade: (db, oldVersion) => {
        switch (oldVersion) {
          case 0:
            db.createObjectStore(OBJECT_STORE_NAME);
        }
      }
    });
  }
  return dbPromise;
}
async function set(appConfig, value) {
  const key = getKey(appConfig);
  const db = await getDbPromise();
  const tx = db.transaction(OBJECT_STORE_NAME, "readwrite");
  const objectStore = tx.objectStore(OBJECT_STORE_NAME);
  const oldValue = await objectStore.get(key);
  await objectStore.put(value, key);
  await tx.done;
  if (!oldValue || oldValue.fid !== value.fid) {
    fidChanged(appConfig, value.fid);
  }
  return value;
}
async function remove(appConfig) {
  const key = getKey(appConfig);
  const db = await getDbPromise();
  const tx = db.transaction(OBJECT_STORE_NAME, "readwrite");
  await tx.objectStore(OBJECT_STORE_NAME).delete(key);
  await tx.done;
}
async function update(appConfig, updateFn) {
  const key = getKey(appConfig);
  const db = await getDbPromise();
  const tx = db.transaction(OBJECT_STORE_NAME, "readwrite");
  const store = tx.objectStore(OBJECT_STORE_NAME);
  const oldValue = await store.get(key);
  const newValue = updateFn(oldValue);
  if (newValue === void 0) {
    await store.delete(key);
  } else {
    await store.put(newValue, key);
  }
  await tx.done;
  if (newValue && (!oldValue || oldValue.fid !== newValue.fid)) {
    fidChanged(appConfig, newValue.fid);
  }
  return newValue;
}
async function getInstallationEntry(installations) {
  let registrationPromise;
  const installationEntry = await update(installations.appConfig, (oldEntry) => {
    const installationEntry2 = updateOrCreateInstallationEntry(oldEntry);
    const entryWithPromise = triggerRegistrationIfNecessary(installations, installationEntry2);
    registrationPromise = entryWithPromise.registrationPromise;
    return entryWithPromise.installationEntry;
  });
  if (installationEntry.fid === INVALID_FID) {
    return { installationEntry: await registrationPromise };
  }
  return {
    installationEntry,
    registrationPromise
  };
}
function updateOrCreateInstallationEntry(oldEntry) {
  const entry = oldEntry || {
    fid: generateFid(),
    registrationStatus: 0
    /* RequestStatus.NOT_STARTED */
  };
  return clearTimedOutRequest(entry);
}
function triggerRegistrationIfNecessary(installations, installationEntry) {
  if (installationEntry.registrationStatus === 0) {
    if (!navigator.onLine) {
      const registrationPromiseWithError = Promise.reject(ERROR_FACTORY.create(
        "app-offline"
        /* ErrorCode.APP_OFFLINE */
      ));
      return {
        installationEntry,
        registrationPromise: registrationPromiseWithError
      };
    }
    const inProgressEntry = {
      fid: installationEntry.fid,
      registrationStatus: 1,
      registrationTime: Date.now()
    };
    const registrationPromise = registerInstallation(installations, inProgressEntry);
    return { installationEntry: inProgressEntry, registrationPromise };
  } else if (installationEntry.registrationStatus === 1) {
    return {
      installationEntry,
      registrationPromise: waitUntilFidRegistration(installations)
    };
  } else {
    return { installationEntry };
  }
}
async function registerInstallation(installations, installationEntry) {
  try {
    const registeredInstallationEntry = await createInstallationRequest(installations, installationEntry);
    return set(installations.appConfig, registeredInstallationEntry);
  } catch (e) {
    if (isServerError(e) && e.customData.serverCode === 409) {
      await remove(installations.appConfig);
    } else {
      await set(installations.appConfig, {
        fid: installationEntry.fid,
        registrationStatus: 0
        /* RequestStatus.NOT_STARTED */
      });
    }
    throw e;
  }
}
async function waitUntilFidRegistration(installations) {
  let entry = await updateInstallationRequest(installations.appConfig);
  while (entry.registrationStatus === 1) {
    await sleep(100);
    entry = await updateInstallationRequest(installations.appConfig);
  }
  if (entry.registrationStatus === 0) {
    const { installationEntry, registrationPromise } = await getInstallationEntry(installations);
    if (registrationPromise) {
      return registrationPromise;
    } else {
      return installationEntry;
    }
  }
  return entry;
}
function updateInstallationRequest(appConfig) {
  return update(appConfig, (oldEntry) => {
    if (!oldEntry) {
      throw ERROR_FACTORY.create(
        "installation-not-found"
        /* ErrorCode.INSTALLATION_NOT_FOUND */
      );
    }
    return clearTimedOutRequest(oldEntry);
  });
}
function clearTimedOutRequest(entry) {
  if (hasInstallationRequestTimedOut(entry)) {
    return {
      fid: entry.fid,
      registrationStatus: 0
      /* RequestStatus.NOT_STARTED */
    };
  }
  return entry;
}
function hasInstallationRequestTimedOut(installationEntry) {
  return installationEntry.registrationStatus === 1 && installationEntry.registrationTime + PENDING_TIMEOUT_MS < Date.now();
}
async function generateAuthTokenRequest({ appConfig, heartbeatServiceProvider }, installationEntry) {
  const endpoint = getGenerateAuthTokenEndpoint(appConfig, installationEntry);
  const headers = getHeadersWithAuth(appConfig, installationEntry);
  const heartbeatService = heartbeatServiceProvider.getImmediate({
    optional: true
  });
  if (heartbeatService) {
    const heartbeatsHeader = await heartbeatService.getHeartbeatsHeader();
    if (heartbeatsHeader) {
      headers.append("x-firebase-client", heartbeatsHeader);
    }
  }
  const body = {
    installation: {
      sdkVersion: PACKAGE_VERSION,
      appId: appConfig.appId
    }
  };
  const request = {
    method: "POST",
    headers,
    body: JSON.stringify(body)
  };
  const response = await retryIfServerError(() => fetch(endpoint, request));
  if (response.ok) {
    const responseValue = await response.json();
    const completedAuthToken = extractAuthTokenInfoFromResponse(responseValue);
    return completedAuthToken;
  } else {
    throw await getErrorFromResponse("Generate Auth Token", response);
  }
}
function getGenerateAuthTokenEndpoint(appConfig, { fid }) {
  return `${getInstallationsEndpoint(appConfig)}/${fid}/authTokens:generate`;
}
async function refreshAuthToken(installations, forceRefresh = false) {
  let tokenPromise;
  const entry = await update(installations.appConfig, (oldEntry) => {
    if (!isEntryRegistered(oldEntry)) {
      throw ERROR_FACTORY.create(
        "not-registered"
        /* ErrorCode.NOT_REGISTERED */
      );
    }
    const oldAuthToken = oldEntry.authToken;
    if (!forceRefresh && isAuthTokenValid(oldAuthToken)) {
      return oldEntry;
    } else if (oldAuthToken.requestStatus === 1) {
      tokenPromise = waitUntilAuthTokenRequest(installations, forceRefresh);
      return oldEntry;
    } else {
      if (!navigator.onLine) {
        throw ERROR_FACTORY.create(
          "app-offline"
          /* ErrorCode.APP_OFFLINE */
        );
      }
      const inProgressEntry = makeAuthTokenRequestInProgressEntry(oldEntry);
      tokenPromise = fetchAuthTokenFromServer(installations, inProgressEntry);
      return inProgressEntry;
    }
  });
  const authToken = tokenPromise ? await tokenPromise : entry.authToken;
  return authToken;
}
async function waitUntilAuthTokenRequest(installations, forceRefresh) {
  let entry = await updateAuthTokenRequest(installations.appConfig);
  while (entry.authToken.requestStatus === 1) {
    await sleep(100);
    entry = await updateAuthTokenRequest(installations.appConfig);
  }
  const authToken = entry.authToken;
  if (authToken.requestStatus === 0) {
    return refreshAuthToken(installations, forceRefresh);
  } else {
    return authToken;
  }
}
function updateAuthTokenRequest(appConfig) {
  return update(appConfig, (oldEntry) => {
    if (!isEntryRegistered(oldEntry)) {
      throw ERROR_FACTORY.create(
        "not-registered"
        /* ErrorCode.NOT_REGISTERED */
      );
    }
    const oldAuthToken = oldEntry.authToken;
    if (hasAuthTokenRequestTimedOut(oldAuthToken)) {
      return Object.assign(Object.assign({}, oldEntry), { authToken: {
        requestStatus: 0
        /* RequestStatus.NOT_STARTED */
      } });
    }
    return oldEntry;
  });
}
async function fetchAuthTokenFromServer(installations, installationEntry) {
  try {
    const authToken = await generateAuthTokenRequest(installations, installationEntry);
    const updatedInstallationEntry = Object.assign(Object.assign({}, installationEntry), { authToken });
    await set(installations.appConfig, updatedInstallationEntry);
    return authToken;
  } catch (e) {
    if (isServerError(e) && (e.customData.serverCode === 401 || e.customData.serverCode === 404)) {
      await remove(installations.appConfig);
    } else {
      const updatedInstallationEntry = Object.assign(Object.assign({}, installationEntry), { authToken: {
        requestStatus: 0
        /* RequestStatus.NOT_STARTED */
      } });
      await set(installations.appConfig, updatedInstallationEntry);
    }
    throw e;
  }
}
function isEntryRegistered(installationEntry) {
  return installationEntry !== void 0 && installationEntry.registrationStatus === 2;
}
function isAuthTokenValid(authToken) {
  return authToken.requestStatus === 2 && !isAuthTokenExpired(authToken);
}
function isAuthTokenExpired(authToken) {
  const now = Date.now();
  return now < authToken.creationTime || authToken.creationTime + authToken.expiresIn < now + TOKEN_EXPIRATION_BUFFER;
}
function makeAuthTokenRequestInProgressEntry(oldEntry) {
  const inProgressAuthToken = {
    requestStatus: 1,
    requestTime: Date.now()
  };
  return Object.assign(Object.assign({}, oldEntry), { authToken: inProgressAuthToken });
}
function hasAuthTokenRequestTimedOut(authToken) {
  return authToken.requestStatus === 1 && authToken.requestTime + PENDING_TIMEOUT_MS < Date.now();
}
async function getId(installations) {
  const installationsImpl = installations;
  const { installationEntry, registrationPromise } = await getInstallationEntry(installationsImpl);
  if (registrationPromise) {
    registrationPromise.catch(console.error);
  } else {
    refreshAuthToken(installationsImpl).catch(console.error);
  }
  return installationEntry.fid;
}
async function getToken(installations, forceRefresh = false) {
  const installationsImpl = installations;
  await completeInstallationRegistration(installationsImpl);
  const authToken = await refreshAuthToken(installationsImpl, forceRefresh);
  return authToken.token;
}
async function completeInstallationRegistration(installations) {
  const { registrationPromise } = await getInstallationEntry(installations);
  if (registrationPromise) {
    await registrationPromise;
  }
}
function extractAppConfig(app) {
  if (!app || !app.options) {
    throw getMissingValueError("App Configuration");
  }
  if (!app.name) {
    throw getMissingValueError("App Name");
  }
  const configKeys = [
    "projectId",
    "apiKey",
    "appId"
  ];
  for (const keyName of configKeys) {
    if (!app.options[keyName]) {
      throw getMissingValueError(keyName);
    }
  }
  return {
    appName: app.name,
    projectId: app.options.projectId,
    apiKey: app.options.apiKey,
    appId: app.options.appId
  };
}
function getMissingValueError(valueName) {
  return ERROR_FACTORY.create("missing-app-config-values", {
    valueName
  });
}
var INSTALLATIONS_NAME = "installations";
var INSTALLATIONS_NAME_INTERNAL = "installations-internal";
var publicFactory = (container) => {
  const app = container.getProvider("app").getImmediate();
  const appConfig = extractAppConfig(app);
  const heartbeatServiceProvider = _getProvider(app, "heartbeat");
  const installationsImpl = {
    app,
    appConfig,
    heartbeatServiceProvider,
    _delete: () => Promise.resolve()
  };
  return installationsImpl;
};
var internalFactory = (container) => {
  const app = container.getProvider("app").getImmediate();
  const installations = _getProvider(app, INSTALLATIONS_NAME).getImmediate();
  const installationsInternal = {
    getId: () => getId(installations),
    getToken: (forceRefresh) => getToken(installations, forceRefresh)
  };
  return installationsInternal;
};
function registerInstallations() {
  _registerComponent(new Component(
    INSTALLATIONS_NAME,
    publicFactory,
    "PUBLIC"
    /* ComponentType.PUBLIC */
  ));
  _registerComponent(new Component(
    INSTALLATIONS_NAME_INTERNAL,
    internalFactory,
    "PRIVATE"
    /* ComponentType.PRIVATE */
  ));
}
registerInstallations();
registerVersion(name, version);
registerVersion(name, version, "esm2017");

// node_modules/@firebase/analytics/dist/esm/index.esm2017.js
var ANALYTICS_TYPE = "analytics";
var GA_FID_KEY = "firebase_id";
var ORIGIN_KEY = "origin";
var FETCH_TIMEOUT_MILLIS = 60 * 1e3;
var DYNAMIC_CONFIG_URL = "https://firebase.googleapis.com/v1alpha/projects/-/apps/{app-id}/webConfig";
var GTAG_URL = "https://www.googletagmanager.com/gtag/js";
var logger = new Logger("@firebase/analytics");
function promiseAllSettled(promises) {
  return Promise.all(promises.map((promise) => promise.catch((e) => e)));
}
function insertScriptTag(dataLayerName2, measurementId) {
  const script = document.createElement("script");
  const url = trustedResourceUrl`https://www.googletagmanager.com/gtag/js?l=${dataLayerName2}&id=${measurementId}`;
  script_exports.setSrc(script, url);
  script.async = true;
  document.head.appendChild(script);
}
function getOrCreateDataLayer(dataLayerName2) {
  let dataLayer = [];
  if (Array.isArray(window[dataLayerName2])) {
    dataLayer = window[dataLayerName2];
  } else {
    window[dataLayerName2] = dataLayer;
  }
  return dataLayer;
}
async function gtagOnConfig(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2, measurementId, gtagParams) {
  const correspondingAppId = measurementIdToAppId2[measurementId];
  try {
    if (correspondingAppId) {
      await initializationPromisesMap2[correspondingAppId];
    } else {
      const dynamicConfigResults = await promiseAllSettled(dynamicConfigPromisesList2);
      const foundConfig = dynamicConfigResults.find((config) => config.measurementId === measurementId);
      if (foundConfig) {
        await initializationPromisesMap2[foundConfig.appId];
      }
    }
  } catch (e) {
    logger.error(e);
  }
  gtagCore("config", measurementId, gtagParams);
}
async function gtagOnEvent(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementId, gtagParams) {
  try {
    let initializationPromisesToWaitFor = [];
    if (gtagParams && gtagParams["send_to"]) {
      let gaSendToList = gtagParams["send_to"];
      if (!Array.isArray(gaSendToList)) {
        gaSendToList = [gaSendToList];
      }
      const dynamicConfigResults = await promiseAllSettled(dynamicConfigPromisesList2);
      for (const sendToId of gaSendToList) {
        const foundConfig = dynamicConfigResults.find((config) => config.measurementId === sendToId);
        const initializationPromise = foundConfig && initializationPromisesMap2[foundConfig.appId];
        if (initializationPromise) {
          initializationPromisesToWaitFor.push(initializationPromise);
        } else {
          initializationPromisesToWaitFor = [];
          break;
        }
      }
    }
    if (initializationPromisesToWaitFor.length === 0) {
      initializationPromisesToWaitFor = Object.values(initializationPromisesMap2);
    }
    await Promise.all(initializationPromisesToWaitFor);
    gtagCore("event", measurementId, gtagParams || {});
  } catch (e) {
    logger.error(e);
  }
}
function wrapGtag(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2) {
  async function gtagWrapper(command, ...args) {
    try {
      if (command === "event") {
        const [measurementId, gtagParams] = args;
        await gtagOnEvent(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementId, gtagParams);
      } else if (command === "config") {
        const [measurementId, gtagParams] = args;
        await gtagOnConfig(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2, measurementId, gtagParams);
      } else if (command === "consent") {
        const [consentAction, gtagParams] = args;
        gtagCore("consent", consentAction, gtagParams);
      } else if (command === "get") {
        const [measurementId, fieldName, callback] = args;
        gtagCore("get", measurementId, fieldName, callback);
      } else if (command === "set") {
        const [customParams] = args;
        gtagCore("set", customParams);
      } else {
        gtagCore(command, ...args);
      }
    } catch (e) {
      logger.error(e);
    }
  }
  return gtagWrapper;
}
function wrapOrCreateGtag(initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2, dataLayerName2, gtagFunctionName) {
  let gtagCore = function(..._args) {
    window[dataLayerName2].push(arguments);
  };
  if (window[gtagFunctionName] && typeof window[gtagFunctionName] === "function") {
    gtagCore = window[gtagFunctionName];
  }
  window[gtagFunctionName] = wrapGtag(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2);
  return {
    gtagCore,
    wrappedGtag: window[gtagFunctionName]
  };
}
function findGtagScriptOnPage(dataLayerName2) {
  const scriptTags = window.document.getElementsByTagName("script");
  for (const tag of Object.values(scriptTags)) {
    if (tag.src && tag.src.includes(GTAG_URL) && tag.src.includes(dataLayerName2)) {
      return tag;
    }
  }
  return null;
}
var ERRORS = {
  [
    "already-exists"
    /* AnalyticsError.ALREADY_EXISTS */
  ]: "A Firebase Analytics instance with the appId {$id}  already exists. Only one Firebase Analytics instance can be created for each appId.",
  [
    "already-initialized"
    /* AnalyticsError.ALREADY_INITIALIZED */
  ]: "initializeAnalytics() cannot be called again with different options than those it was initially called with. It can be called again with the same options to return the existing instance, or getAnalytics() can be used to get a reference to the already-intialized instance.",
  [
    "already-initialized-settings"
    /* AnalyticsError.ALREADY_INITIALIZED_SETTINGS */
  ]: "Firebase Analytics has already been initialized.settings() must be called before initializing any Analytics instanceor it will have no effect.",
  [
    "interop-component-reg-failed"
    /* AnalyticsError.INTEROP_COMPONENT_REG_FAILED */
  ]: "Firebase Analytics Interop Component failed to instantiate: {$reason}",
  [
    "invalid-analytics-context"
    /* AnalyticsError.INVALID_ANALYTICS_CONTEXT */
  ]: "Firebase Analytics is not supported in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}",
  [
    "indexeddb-unavailable"
    /* AnalyticsError.INDEXEDDB_UNAVAILABLE */
  ]: "IndexedDB unavailable or restricted in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}",
  [
    "fetch-throttle"
    /* AnalyticsError.FETCH_THROTTLE */
  ]: "The config fetch request timed out while in an exponential backoff state. Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.",
  [
    "config-fetch-failed"
    /* AnalyticsError.CONFIG_FETCH_FAILED */
  ]: "Dynamic config fetch failed: [{$httpStatus}] {$responseMessage}",
  [
    "no-api-key"
    /* AnalyticsError.NO_API_KEY */
  ]: 'The "apiKey" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid API key.',
  [
    "no-app-id"
    /* AnalyticsError.NO_APP_ID */
  ]: 'The "appId" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid app ID.',
  [
    "no-client-id"
    /* AnalyticsError.NO_CLIENT_ID */
  ]: 'The "client_id" field is empty.',
  [
    "invalid-gtag-resource"
    /* AnalyticsError.INVALID_GTAG_RESOURCE */
  ]: "Trusted Types detected an invalid gtag resource: {$gtagURL}."
};
var ERROR_FACTORY2 = new ErrorFactory("analytics", "Analytics", ERRORS);
var LONG_RETRY_FACTOR = 30;
var BASE_INTERVAL_MILLIS = 1e3;
var RetryData = class {
  constructor(throttleMetadata = {}, intervalMillis = BASE_INTERVAL_MILLIS) {
    this.throttleMetadata = throttleMetadata;
    this.intervalMillis = intervalMillis;
  }
  getThrottleMetadata(appId) {
    return this.throttleMetadata[appId];
  }
  setThrottleMetadata(appId, metadata) {
    this.throttleMetadata[appId] = metadata;
  }
  deleteThrottleMetadata(appId) {
    delete this.throttleMetadata[appId];
  }
};
var defaultRetryData = new RetryData();
function getHeaders2(apiKey) {
  return new Headers({
    Accept: "application/json",
    "x-goog-api-key": apiKey
  });
}
async function fetchDynamicConfig(appFields) {
  var _a;
  const { appId, apiKey } = appFields;
  const request = {
    method: "GET",
    headers: getHeaders2(apiKey)
  };
  const appUrl = DYNAMIC_CONFIG_URL.replace("{app-id}", appId);
  const response = await fetch(appUrl, request);
  if (response.status !== 200 && response.status !== 304) {
    let errorMessage = "";
    try {
      const jsonResponse = await response.json();
      if ((_a = jsonResponse.error) === null || _a === void 0 ? void 0 : _a.message) {
        errorMessage = jsonResponse.error.message;
      }
    } catch (_ignored) {
    }
    throw ERROR_FACTORY2.create("config-fetch-failed", {
      httpStatus: response.status,
      responseMessage: errorMessage
    });
  }
  return response.json();
}
async function fetchDynamicConfigWithRetry(app, retryData = defaultRetryData, timeoutMillis) {
  const { appId, apiKey, measurementId } = app.options;
  if (!appId) {
    throw ERROR_FACTORY2.create(
      "no-app-id"
      /* AnalyticsError.NO_APP_ID */
    );
  }
  if (!apiKey) {
    if (measurementId) {
      return {
        measurementId,
        appId
      };
    }
    throw ERROR_FACTORY2.create(
      "no-api-key"
      /* AnalyticsError.NO_API_KEY */
    );
  }
  const throttleMetadata = retryData.getThrottleMetadata(appId) || {
    backoffCount: 0,
    throttleEndTimeMillis: Date.now()
  };
  const signal = new AnalyticsAbortSignal();
  setTimeout(async () => {
    signal.abort();
  }, timeoutMillis !== void 0 ? timeoutMillis : FETCH_TIMEOUT_MILLIS);
  return attemptFetchDynamicConfigWithRetry({ appId, apiKey, measurementId }, throttleMetadata, signal, retryData);
}
async function attemptFetchDynamicConfigWithRetry(appFields, { throttleEndTimeMillis, backoffCount }, signal, retryData = defaultRetryData) {
  var _a;
  const { appId, measurementId } = appFields;
  try {
    await setAbortableTimeout(signal, throttleEndTimeMillis);
  } catch (e) {
    if (measurementId) {
      logger.warn(`Timed out fetching this Firebase app's measurement ID from the server. Falling back to the measurement ID ${measurementId} provided in the "measurementId" field in the local Firebase config. [${e === null || e === void 0 ? void 0 : e.message}]`);
      return { appId, measurementId };
    }
    throw e;
  }
  try {
    const response = await fetchDynamicConfig(appFields);
    retryData.deleteThrottleMetadata(appId);
    return response;
  } catch (e) {
    const error = e;
    if (!isRetriableError(error)) {
      retryData.deleteThrottleMetadata(appId);
      if (measurementId) {
        logger.warn(`Failed to fetch this Firebase app's measurement ID from the server. Falling back to the measurement ID ${measurementId} provided in the "measurementId" field in the local Firebase config. [${error === null || error === void 0 ? void 0 : error.message}]`);
        return { appId, measurementId };
      } else {
        throw e;
      }
    }
    const backoffMillis = Number((_a = error === null || error === void 0 ? void 0 : error.customData) === null || _a === void 0 ? void 0 : _a.httpStatus) === 503 ? calculateBackoffMillis(backoffCount, retryData.intervalMillis, LONG_RETRY_FACTOR) : calculateBackoffMillis(backoffCount, retryData.intervalMillis);
    const throttleMetadata = {
      throttleEndTimeMillis: Date.now() + backoffMillis,
      backoffCount: backoffCount + 1
    };
    retryData.setThrottleMetadata(appId, throttleMetadata);
    logger.debug(`Calling attemptFetch again in ${backoffMillis} millis`);
    return attemptFetchDynamicConfigWithRetry(appFields, throttleMetadata, signal, retryData);
  }
}
function setAbortableTimeout(signal, throttleEndTimeMillis) {
  return new Promise((resolve, reject) => {
    const backoffMillis = Math.max(throttleEndTimeMillis - Date.now(), 0);
    const timeout = setTimeout(resolve, backoffMillis);
    signal.addEventListener(() => {
      clearTimeout(timeout);
      reject(ERROR_FACTORY2.create("fetch-throttle", {
        throttleEndTimeMillis
      }));
    });
  });
}
function isRetriableError(e) {
  if (!(e instanceof FirebaseError) || !e.customData) {
    return false;
  }
  const httpStatus = Number(e.customData["httpStatus"]);
  return httpStatus === 429 || httpStatus === 500 || httpStatus === 503 || httpStatus === 504;
}
var AnalyticsAbortSignal = class {
  constructor() {
    this.listeners = [];
  }
  addEventListener(listener) {
    this.listeners.push(listener);
  }
  abort() {
    this.listeners.forEach((listener) => listener());
  }
};
var defaultEventParametersForInit;
async function logEvent$1(gtagFunction, initializationPromise, eventName, eventParams, options) {
  if (options && options.global) {
    gtagFunction("event", eventName, eventParams);
    return;
  } else {
    const measurementId = await initializationPromise;
    const params = Object.assign(Object.assign({}, eventParams), { "send_to": measurementId });
    gtagFunction("event", eventName, params);
  }
}
async function setCurrentScreen$1(gtagFunction, initializationPromise, screenName, options) {
  if (options && options.global) {
    gtagFunction("set", { "screen_name": screenName });
    return Promise.resolve();
  } else {
    const measurementId = await initializationPromise;
    gtagFunction("config", measurementId, {
      update: true,
      "screen_name": screenName
    });
  }
}
async function setUserId$1(gtagFunction, initializationPromise, id, options) {
  if (options && options.global) {
    gtagFunction("set", { "user_id": id });
    return Promise.resolve();
  } else {
    const measurementId = await initializationPromise;
    gtagFunction("config", measurementId, {
      update: true,
      "user_id": id
    });
  }
}
async function setUserProperties$1(gtagFunction, initializationPromise, properties, options) {
  if (options && options.global) {
    const flatProperties = {};
    for (const key of Object.keys(properties)) {
      flatProperties[`user_properties.${key}`] = properties[key];
    }
    gtagFunction("set", flatProperties);
    return Promise.resolve();
  } else {
    const measurementId = await initializationPromise;
    gtagFunction("config", measurementId, {
      update: true,
      "user_properties": properties
    });
  }
}
async function internalGetGoogleAnalyticsClientId(gtagFunction, initializationPromise) {
  const measurementId = await initializationPromise;
  return new Promise((resolve, reject) => {
    gtagFunction("get", measurementId, "client_id", (clientId) => {
      if (!clientId) {
        reject(ERROR_FACTORY2.create(
          "no-client-id"
          /* AnalyticsError.NO_CLIENT_ID */
        ));
      }
      resolve(clientId);
    });
  });
}
async function setAnalyticsCollectionEnabled$1(initializationPromise, enabled) {
  const measurementId = await initializationPromise;
  window[`ga-disable-${measurementId}`] = !enabled;
}
var defaultConsentSettingsForInit;
function _setConsentDefaultForInit(consentSettings) {
  defaultConsentSettingsForInit = consentSettings;
}
function _setDefaultEventParametersForInit(customParams) {
  defaultEventParametersForInit = customParams;
}
async function validateIndexedDB() {
  if (!isIndexedDBAvailable()) {
    logger.warn(ERROR_FACTORY2.create("indexeddb-unavailable", {
      errorInfo: "IndexedDB is not available in this environment."
    }).message);
    return false;
  } else {
    try {
      await validateIndexedDBOpenable();
    } catch (e) {
      logger.warn(ERROR_FACTORY2.create("indexeddb-unavailable", {
        errorInfo: e === null || e === void 0 ? void 0 : e.toString()
      }).message);
      return false;
    }
  }
  return true;
}
async function _initializeAnalytics(app, dynamicConfigPromisesList2, measurementIdToAppId2, installations, gtagCore, dataLayerName2, options) {
  var _a;
  const dynamicConfigPromise = fetchDynamicConfigWithRetry(app);
  dynamicConfigPromise.then((config) => {
    measurementIdToAppId2[config.measurementId] = config.appId;
    if (app.options.measurementId && config.measurementId !== app.options.measurementId) {
      logger.warn(`The measurement ID in the local Firebase config (${app.options.measurementId}) does not match the measurement ID fetched from the server (${config.measurementId}). To ensure analytics events are always sent to the correct Analytics property, update the measurement ID field in the local config or remove it from the local config.`);
    }
  }).catch((e) => logger.error(e));
  dynamicConfigPromisesList2.push(dynamicConfigPromise);
  const fidPromise = validateIndexedDB().then((envIsValid) => {
    if (envIsValid) {
      return installations.getId();
    } else {
      return void 0;
    }
  });
  const [dynamicConfig, fid] = await Promise.all([
    dynamicConfigPromise,
    fidPromise
  ]);
  if (!findGtagScriptOnPage(dataLayerName2)) {
    insertScriptTag(dataLayerName2, dynamicConfig.measurementId);
  }
  if (defaultConsentSettingsForInit) {
    gtagCore("consent", "default", defaultConsentSettingsForInit);
    _setConsentDefaultForInit(void 0);
  }
  gtagCore("js", /* @__PURE__ */ new Date());
  const configProperties = (_a = options === null || options === void 0 ? void 0 : options.config) !== null && _a !== void 0 ? _a : {};
  configProperties[ORIGIN_KEY] = "firebase";
  configProperties.update = true;
  if (fid != null) {
    configProperties[GA_FID_KEY] = fid;
  }
  gtagCore("config", dynamicConfig.measurementId, configProperties);
  if (defaultEventParametersForInit) {
    gtagCore("set", defaultEventParametersForInit);
    _setDefaultEventParametersForInit(void 0);
  }
  return dynamicConfig.measurementId;
}
var AnalyticsService = class {
  constructor(app) {
    this.app = app;
  }
  _delete() {
    delete initializationPromisesMap[this.app.options.appId];
    return Promise.resolve();
  }
};
var initializationPromisesMap = {};
var dynamicConfigPromisesList = [];
var measurementIdToAppId = {};
var dataLayerName = "dataLayer";
var gtagName = "gtag";
var gtagCoreFunction;
var wrappedGtagFunction;
var globalInitDone = false;
function settings(options) {
  if (globalInitDone) {
    throw ERROR_FACTORY2.create(
      "already-initialized"
      /* AnalyticsError.ALREADY_INITIALIZED */
    );
  }
  if (options.dataLayerName) {
    dataLayerName = options.dataLayerName;
  }
  if (options.gtagName) {
    gtagName = options.gtagName;
  }
}
function warnOnBrowserContextMismatch() {
  const mismatchedEnvMessages = [];
  if (isBrowserExtension()) {
    mismatchedEnvMessages.push("This is a browser extension environment.");
  }
  if (!areCookiesEnabled()) {
    mismatchedEnvMessages.push("Cookies are not available.");
  }
  if (mismatchedEnvMessages.length > 0) {
    const details = mismatchedEnvMessages.map((message, index) => `(${index + 1}) ${message}`).join(" ");
    const err = ERROR_FACTORY2.create("invalid-analytics-context", {
      errorInfo: details
    });
    logger.warn(err.message);
  }
}
function factory(app, installations, options) {
  warnOnBrowserContextMismatch();
  const appId = app.options.appId;
  if (!appId) {
    throw ERROR_FACTORY2.create(
      "no-app-id"
      /* AnalyticsError.NO_APP_ID */
    );
  }
  if (!app.options.apiKey) {
    if (app.options.measurementId) {
      logger.warn(`The "apiKey" field is empty in the local Firebase config. This is needed to fetch the latest measurement ID for this Firebase app. Falling back to the measurement ID ${app.options.measurementId} provided in the "measurementId" field in the local Firebase config.`);
    } else {
      throw ERROR_FACTORY2.create(
        "no-api-key"
        /* AnalyticsError.NO_API_KEY */
      );
    }
  }
  if (initializationPromisesMap[appId] != null) {
    throw ERROR_FACTORY2.create("already-exists", {
      id: appId
    });
  }
  if (!globalInitDone) {
    getOrCreateDataLayer(dataLayerName);
    const { wrappedGtag, gtagCore } = wrapOrCreateGtag(initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, dataLayerName, gtagName);
    wrappedGtagFunction = wrappedGtag;
    gtagCoreFunction = gtagCore;
    globalInitDone = true;
  }
  initializationPromisesMap[appId] = _initializeAnalytics(app, dynamicConfigPromisesList, measurementIdToAppId, installations, gtagCoreFunction, dataLayerName, options);
  const analyticsInstance = new AnalyticsService(app);
  return analyticsInstance;
}
function getAnalytics(app = getApp()) {
  app = getModularInstance(app);
  const analyticsProvider = _getProvider(app, ANALYTICS_TYPE);
  if (analyticsProvider.isInitialized()) {
    return analyticsProvider.getImmediate();
  }
  return initializeAnalytics(app);
}
function initializeAnalytics(app, options = {}) {
  const analyticsProvider = _getProvider(app, ANALYTICS_TYPE);
  if (analyticsProvider.isInitialized()) {
    const existingInstance = analyticsProvider.getImmediate();
    if (deepEqual(options, analyticsProvider.getOptions())) {
      return existingInstance;
    } else {
      throw ERROR_FACTORY2.create(
        "already-initialized"
        /* AnalyticsError.ALREADY_INITIALIZED */
      );
    }
  }
  const analyticsInstance = analyticsProvider.initialize({ options });
  return analyticsInstance;
}
async function isSupported() {
  if (isBrowserExtension()) {
    return false;
  }
  if (!areCookiesEnabled()) {
    return false;
  }
  if (!isIndexedDBAvailable()) {
    return false;
  }
  try {
    const isDBOpenable = await validateIndexedDBOpenable();
    return isDBOpenable;
  } catch (error) {
    return false;
  }
}
function setCurrentScreen(analyticsInstance, screenName, options) {
  analyticsInstance = getModularInstance(analyticsInstance);
  setCurrentScreen$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], screenName, options).catch((e) => logger.error(e));
}
async function getGoogleAnalyticsClientId(analyticsInstance) {
  analyticsInstance = getModularInstance(analyticsInstance);
  return internalGetGoogleAnalyticsClientId(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId]);
}
function setUserId(analyticsInstance, id, options) {
  analyticsInstance = getModularInstance(analyticsInstance);
  setUserId$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], id, options).catch((e) => logger.error(e));
}
function setUserProperties(analyticsInstance, properties, options) {
  analyticsInstance = getModularInstance(analyticsInstance);
  setUserProperties$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], properties, options).catch((e) => logger.error(e));
}
function setAnalyticsCollectionEnabled(analyticsInstance, enabled) {
  analyticsInstance = getModularInstance(analyticsInstance);
  setAnalyticsCollectionEnabled$1(initializationPromisesMap[analyticsInstance.app.options.appId], enabled).catch((e) => logger.error(e));
}
function setDefaultEventParameters(customParams) {
  if (wrappedGtagFunction) {
    wrappedGtagFunction("set", customParams);
  } else {
    _setDefaultEventParametersForInit(customParams);
  }
}
function logEvent(analyticsInstance, eventName, eventParams, options) {
  analyticsInstance = getModularInstance(analyticsInstance);
  logEvent$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], eventName, eventParams, options).catch((e) => logger.error(e));
}
function setConsent(consentSettings) {
  if (wrappedGtagFunction) {
    wrappedGtagFunction("consent", "update", consentSettings);
  } else {
    _setConsentDefaultForInit(consentSettings);
  }
}
var name2 = "@firebase/analytics";
var version2 = "0.10.6";
function registerAnalytics() {
  _registerComponent(new Component(
    ANALYTICS_TYPE,
    (container, { options: analyticsOptions }) => {
      const app = container.getProvider("app").getImmediate();
      const installations = container.getProvider("installations-internal").getImmediate();
      return factory(app, installations, analyticsOptions);
    },
    "PUBLIC"
    /* ComponentType.PUBLIC */
  ));
  _registerComponent(new Component(
    "analytics-internal",
    internalFactory2,
    "PRIVATE"
    /* ComponentType.PRIVATE */
  ));
  registerVersion(name2, version2);
  registerVersion(name2, version2, "esm2017");
  function internalFactory2(container) {
    try {
      const analytics = container.getProvider(ANALYTICS_TYPE).getImmediate();
      return {
        logEvent: (eventName, eventParams, options) => logEvent(analytics, eventName, eventParams, options)
      };
    } catch (e) {
      throw ERROR_FACTORY2.create("interop-component-reg-failed", {
        reason: e
      });
    }
  }
}
registerAnalytics();
export {
  getAnalytics,
  getGoogleAnalyticsClientId,
  initializeAnalytics,
  isSupported,
  logEvent,
  setAnalyticsCollectionEnabled,
  setConsent,
  setCurrentScreen,
  setDefaultEventParameters,
  setUserId,
  setUserProperties,
  settings
};
/*! Bundled license information:

safevalues/dist/mjs/environment/dev.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/internals/secrets.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/internals/attribute_impl.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/internals/string_literal.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/builders/sensitive_attributes.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/builders/attribute_builders.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/internals/trusted_types.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/internals/html_impl.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/builders/document_fragment_builders.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/internals/resource_url_impl.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/internals/script_impl.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/builders/html_builders.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/internals/pure.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/builders/url_builders.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/globals/range.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/builders/html_sanitizer/inert_fragment.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/builders/html_sanitizer/no_clobber.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/builders/html_sanitizer/resource_url_policy.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/builders/html_sanitizer/sanitizer_table/sanitizer_table.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/builders/html_sanitizer/sanitizer_table/default_sanitizer_table.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/builders/html_sanitizer/html_sanitizer.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/builders/html_sanitizer/html_sanitizer_builder.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/builders/resource_url_builders.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/builders/script_builders.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/internals/style_sheet_impl.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/builders/style_sheet_builders.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/index.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/elements/anchor.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/elements/area.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/elements/base.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/elements/button.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/elements/element.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/elements/embed.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/elements/form.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/elements/iframe.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/elements/input.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/elements/link.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/elements/object.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/globals/window.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/elements/script.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/elements/style.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/elements/svg.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/elements/svg_use.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/globals/document.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/globals/dom_parser.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/globals/fetch.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/globals/global.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/globals/location.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/globals/service_worker_container.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/globals/url.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/globals/worker.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

safevalues/dist/mjs/dom/index.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)

@firebase/installations/dist/esm/index.esm2017.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/installations/dist/esm/index.esm2017.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/installations/dist/esm/index.esm2017.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/installations/dist/esm/index.esm2017.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/installations/dist/esm/index.esm2017.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/installations/dist/esm/index.esm2017.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/analytics/dist/esm/index.esm2017.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
*/
//# sourceMappingURL=firebase_analytics.js.map
